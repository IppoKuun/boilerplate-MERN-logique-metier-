BACKEND SECURE MERN

.env
Pour le fichier .env ont mets :
NODE_ENV=development   # ou production
MONGO_URI=...
SESSION_SECRET=...
CORS_ORIGINS=https://admin.tondomaine.com
TRUST_PROXY=1    
Env.js
On importe la lib dotend puis l’attribue sur .config.

On fait notre premier helpers.
Une fonction toBool avec la valeur, le state par défaut qu’on défini sur false, Et qui servira a  qui vas convertir en true/false. 

Si le type est booléen on retourne la valeur
Si il n’est pas un str on retour la valeur par def ( false )
On créer une constaante qui vas être la valeur nettoyé avec trim et ttminuscule.
Si la valeur est compris dans true, 1, yes et y on return true mais si elle est comprie dans false 0, noon n on return false
Et si aucune regle ne correspond on retourn faux.

Ensuite on passe a une fonction toInt pr convertir en entier ce qui est en str. Avec la valeur et son défaut.
On créer une constante qui vas être le la valeur mais paseInt, et en base 10.

Dernier fonction, toArrayCSV qui vas servir a convertir les chaine de caractere qui sont enft des tab en tab de valeur.
On prend la fonction et sa valeur + un défaut qui sera un tab vide.
Si ya pas de valeur ou bien la valeur est un str on retourne la valeur par défaut qui est tab vide.
Sinon on retourne la valeur avec ou on divise a chaque ,  et chaque partie qui a été divisé doit être parcouru pour enlevé les espace et on filtre ce qu’il reste.
Pour finir on fait une fonction assert qui sert a si une condition est fausse on ne la valide pas et retourne un msg d’erreur.
Fonction accompagné d’une condition et un msg.
Si la condition n’est pas remplis :
On throw un new er ren disant que ça vient de l’env.

Ensuite on défini le mode

Et après, on importe tout les RAW.

Une fois importer on commence le parsing avec nos helpers.
Ont mets le port, le cookie secure que si on est en prod

Trusy_proxy on doit le convert en entier et si on est en prod = 1 : 0
Corsorigins. On doit, c’est probablement une chainer de carac donc on convert en arryCSV si on est prod c’est tab vide sinon ça tourne en local.

Mtn on utilise nos fonction assert.
1 : Si Ya pas de mongu uri et qu’on est en prod le serveur doit s’arreté.

Parreil si on est en prod et pas de session_secret.
On créer const sameSite qui prends la valeur du cookie_same_site en minuscult.
Et si lax strict et non n’est pas dedans le serveur doit s’arrete.

Et si on a pas de sameSite et qu’on est en prod il faut un cookie_secure sinon ça fonctionne pas.


Ensuite on exporte tout ça en l’appelant config et en gelant la constante:
On exporte l’env, « is_prd’, le port, mongu :uri qui est dans le RAW ou notre truc mongo par defaut.

Pour la session :
Le secr ou bien au dev de changer.
Le nom du cookie
Et pr le cookie :
On lui donne un max age qui vas être de 7j (ms)
Secure sera cookie_secure
httpOnly true
sameSite :sameSite
domaine : sois celui qu’on a définie sois undefined.
ET le parh sera « / »

Pr le cors on vas autorisé tt les cors_origins
http :trustproxy
log :
level : raw.LOG_LEVEL

et on export default


SERVER.js
On importe toute la clique (exp asynnc err, mongoose, helmet, cors, session from express-session mongoStore, notre env.js et les routh d’authentification.

On se connecte d’abord a DB :
On importe notre URL de notre config.
On fait la connexion avec l’url en param et on timeout pour pas que le serv bloque au démarrage.
Mongoose.connection vas être utilisé pr des arrow function pour vois si il est connecté, si ya un erreur ou si deconnecté.

Ensuite oncreer  l’app express.
Si trustproxy existe on le configure a notre app

Ensuite avec store Mongo on fait un store temp comme pr notre session
On prendre notre URL : on mets un timeout = a la durée de notre session . Et mongo reecris minimum tt les 300sec la session.

Ensuite notre app doit importer tout ce qui a de env en rapport avec session/cookie et en ajtant :
    resave: false, // ne pas re-sauver si pas modifiée
    saveUninitialized: false, // pas de session vide créée
    store: sessionStore,

Pour les routes, on fait un petit endpoint get health qui retourne un JSON qui dit si le serv est OK, l’environement et le temps et db: mongoose.connection.readyState === 1 ? "up" : "down",

Pour le express-async-error on vas l’utilisé ici.
On prends le statuts, on vérifie qu’on est en prod pck on vas en avoir besoin.
Et un json qui sera ce qu’on vas envoyé en DB qui contiendra : l’erreur. Et si on est en pas en prod on envoie la stack mais en PROD JAMAIS.

Si le status est 500 ou + console.log l’erreur, sinon un warn. ET ENFIN on envoit tout au naviguateur, le status et notre JSON


A LA FIN on mets le démarrage di serveur en fonction
On  connectMongo()
On branche notre app sur notre port et on mets un consol log que notre serv march sur  le port X et qu’on est en env.

Si ça marche pas on console log une erreur en disant c laquell.

Hash.js
On importe bcrypt.
On export la constante bcrypt cost qui sera de 12.

On exporte une fonctionex hashpassword ou on vas vérifié que le mdp écrit « plain » est bien un str et est pas égal a 0 sinon on jette une nvl error.

Enuiste on génére un sel avec bcrypt.genSalt et on hash le plain avec le salt et on return le mdp hashé.

Enfin on exporte une fonction qui va vérifié si ce que l’utilisateur a mis est bien str et pas vide, pareil pr le hash.
Et on retourne   return bcrypt.compare(plain, hash);

User.js

On import mongoose et nos fonction hash+verify de hash.js
On importe la constante schema de mongoose.
On créer notre schema avc new Schema
Ou on mets : username (champs : str, obligé, index et unique + trim et minuscule)
passwordHash (str, obligé et select : false)
rôle (str, cat :admin, manager, viewer), default :admin, index : true)
displayName, le nom affiché en str, trim et default « »

On mets un statut pour si il est active ou non, par default il est actif.

LastLoginAt type date default null

AUDIT minimal avec la creation et updated.
}
Ensuite on active le format timstamps
On enleve versionKey.

Et on prepare ce qui peut être envoyé par JSON avec le toJSON : transform : qui prends une fonction(doc, ret), on enleve  passordhash et on retourn ret.


MAINTENANT :
Mtn pr notre schema on créer une méthode setPassword qui vas vérifié que le password hashé et bien pareil que ce que l’user vas mettre.

Et autre methode ou compare avec bcrypt compare si ce que l’user a envoyé avec le MDP hashé qu’on a (dabors on verifie si ya bien un MDP hashé)

On recupere avec notre modele + modele statics l’username + son MDP hashé
Il faut qu’avec l’index on fair que username est unique de partout 1 role 1 statue 1username.

Enfin on exporte comme ça :
export const User = mongoose.models.User || mongoose.model("User", userSchema);
export default User;

validate.js

on importe Joi et le sanitize de sanitize.js

on exporte Joi pr le repartager dans tt les routes.

On crréer un settings par défaut de JOI avec convert true aborteralyfalse, stripunknow true et allowunknow false.

On créer un msg de format joi propre.
Si ya pas d’erreur on retourn un tab vide mais sinon on parcour chaque err detail, on change son chemin :
Si c’est un tab on enleve les . et on les rassemble, mais si c’est un str on envoie le chemon de l’erreur ou si yen a pas une chaine vide.

Le msg : String(d.message || "").replace(/["]/g, "'"),

Le type : on envoie juste le typeou validation error

On exporte la fonction validate qui retourne le schemaMap et l’option en param (obj les 2)



Ensuite on créer une constante qui vas prendre en compte chaque partie de requête, headers, params, query et body. 
Puis on filtre que les partie pris en compte dans shemaMap

Si il ya rien on retourne une fonction qui retourne que next().

Ensuite on fait un autre function qui validateMiddleware qui prends en  parametre la requte, la reponse et next.

Donc on vas pour chaque part de tout les part.
On prendre la clé de la part choisis.

Et ensuite in creeer un input qui sera la part de la requête ( si il existe pas on renvoie un obj vide)
Et ensuite si les part sont bien tout sauf headears . Notre input sera l’input de la fonction sanitize.

Et il faut qu’on fasse une option pour les headers, pour les autorisé. Ou on ajoutera a notre options par defaut.

Et enfin, on utilise la fonction validate pr utilisé la fonction sur ce qu’on ce qu’on a.
Et si ya une err onmets le status sur 400 et envoie un JSON avec lerreur, le lieu et le detail qu’on envoie avec format JSON.

Puis on rempace le brut par la valeur.

Et on retourne next car c’est un middleware.

RateLimits.js

On importe rate imit.

On fait un ptit helper pour retourner proprement une reponse.
Avec statut 429 + un JSON avec error : »xx »

La on fait une fonction loginrateLimiter ou on vas calculer la durée de l’ecran et ensuite le nbr de tentative.
On actvie standarHeadres et desac legacyHeaders+skipsuccesfulrequest.
On fait un handler dans le rateLimit qui prends requête, reponse et _next + options. Ou on fait que pr retry on donne la limite en temps (ou grosse valeur) sur 1000
Et on retourne la fonction helper  avec une reponse et la limitre retry qu’on vient de mettre.

On genere une clé qui prendre reponse et requête en param.
On créer l’ip qui est l’ip ou  req.socket?.remoteAddres ou bien inconnu
+ l’utilisateur ou (on verifie qu’il esy present) si il est bien = a un str, si oui on le prends, nettoyé, sinon on envoie un str vide.
Et ou retourne si on a username, ip + username sinon que l’ip.
Login.js
On importe l’environnement et le model.

On fait une fonction login.
On fait une constante AUTH_ERR pour la reutilisé et la mettre a chaque fois.

On cherche l’utilisateur dans la DB avec tout les champs qui nous interesse. Si ya pas d’utilisateur ou que il est en status pas actif on renvoie une err.

On verifie le MDP avec fonction de mongo

On fait un snapchoy minimal pour gardé l’identité.
Si user a coche se souvenir de moi son la duree de son cookie sera egal a celle dans maxage.

Et ensuite on retourne OK avec l’utilisateur en JSON.
Logout.js
On prends le nom du cookie et session. 
Si pas de session on enleve le cookies.

Si yen a on detruit la session + clear cookies
Et enfin on renvoie une bonne err.


RequireAuth.js
On créer une fonction avec le rôle en param. 
On prend l’user de la session, si il n’yen a pas, il ‘est pas autorisé donc err

On verifie que le roles est bien dans un tab et qu’il contient un rôle.
Ensuite on prend le rôle de notre utilisateur et si il n’est pas inclus dans le roles qu’on mets en arguments on envoie une erreur.

Ensuite on fait req.user = user pour qu’on a nos donné qu’avec user.
On  fait un ptit logs avec la date de l’activité lip et l’agent ( si ya une session biensur )
Et on fait un fichier auth.routes les routes d’API.

Et on ajt ça :
router.get("/me", requireAuth(), (req, res) => {
  return res.status(200).json({ user: req.user });




queryBuilder.js
AU DEPART on fait des liste pour les champs autorisé pour le tri, des champs qu’on tri par égalité et des champs qu’on tri par range.

On fait une fonction pour la range  quand on tri.
On fait un obj qui sera le query[champ]

On prends min/max avec plusieurs méthode

Et la on retourne un obj qui vas prendre en max et min respectivement $gte ou $lte en. Si il ya une clé dans cette obj, on retourne lobj sinon undefined

La on creeer la fonction qui vas créer le query.
On créer l’obj avec les valeurs par défaut.

Ensuite on créer une boucle ou on vas prendre chaque champs parmi ceux autorié, et si si il y’a bien un champs dans le query,. Le query sera ajt avc son champs. 
Pareil pour ranges, sauf qu’on mets le champsdans la fonction range.
Et si on a reussi, ça rentre dans filter.


Pour le tri : 
Constante pour trier le type et ensuite l’ordre et on expot dans une constat sort avec le type l’ordre
