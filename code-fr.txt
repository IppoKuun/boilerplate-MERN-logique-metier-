Presque ! Il te manque juste **quelques ajustements** pour que ça marche “plug & play” sans surprises. Là, ton snippet mélange deux approches (console **ou** Mongo), et il y a des **mismatches de schéma**.

# Ce qu’il faut faire (ultra-clair)

## 1) **Sépare bien** modèle et helper (et choisis **une seule** stratégie)

* **Modèle** `models/AuditEvent.js` (persistance Mongo)
* **Helper** `utils/audit.js` (écrit 1 doc d’audit par action)
* **Route** `routes/admin.audit.routes.js` (lecture paginée/filtrée)

> Évite d’avoir **deux fonctions** `audit()` (une console + une Mongo) dans le même fichier. Choisis **celle Mongo** (persistante).

---

## 2) Fichiers corrigés (copie/colle)

### `models/AuditEvent.js`

```js
// models/AuditEvent.js (ESM)
import mongoose from "mongoose";

const AuditEventSchema = new mongoose.Schema({
  ts:   { type: Date, default: () => new Date(), index: true },
  event:{ type: String, required: true, index: true },     // ex: "product.update"
  actor:{                                                   // QUI
    id: String, role: String, org: String, impersonating: String
  },
  target:{ type: { type: String }, id: String, slug: String }, // QUOI
  source:{ via: String, ip: String, ua: String },           // UI/API/JOB + IP/UA
  reason: String,
  diff: mongoose.Schema.Types.Mixed,
  correlationId: String
}, { versionKey: false });

AuditEventSchema.index({ "target.id": 1, ts: -1 });
AuditEventSchema.index({ "actor.id": 1, ts: -1 });
// Option rétention auto (à valider avec le client)
// AuditEventSchema.index({ ts: 1 }, { expireAfterSeconds: 60*60*24*90 });

export default mongoose.model("AuditEvent", AuditEventSchema, "audit_events");
```

### `utils/audit.js`

```js
// utils/audit.js
import AuditEvent from "../models/AuditEvent.js";

export async function audit(req, payload) {
  const base = {
    ts: new Date(),
    actor: {
      id:   req.user?.id || req.user?.username || req.session?.user?.username || "anonymous",
      role: req.user?.role || req.session?.user?.role || "unknown",
      org:  req.user?.orgId || null,
      impersonating: req.user?.impersonating || null,
    },
    source: {
      via: req.apiKey ? "api" : "ui",
      ip:  req.ip,
      ua:  req.headers["user-agent"] || "unknown",
    },
    correlationId: req.id || req.headers["x-request-id"] || null,
    ...payload,
  };

  try {
    await AuditEvent.create(base);   // ⬅️ écrit en base
  } catch (e) {
    // fallback console si la base refuse (pour ne rien perdre en dev)
    console.log("[audit-fallback]", JSON.stringify(base));
  }
}
```

### `routes/admin.audit.routes.js`

```js
// routes/admin.audit.routes.js
import { Router } from "express";
import requireAuth from "../middlewares/requireAuth.js";
import AuditEvent from "../models/AuditEvent.js";
import { queryBuilder } from "../utils/queryBuilder.js";
import { pagination, buildMeta } from "../utils/pagination.js";

const r = Router();

r.get("/audit", requireAuth(["owner","superadmin"]), async (req, res) => {
  // Filtrage/tri (prévois "ts" en range)
  const { filter, sort, sortBy, order } = queryBuilder(req.query, {
    equals: new Set(["event", "actor.id", "target.id"]),
    ranges: new Set(["ts"]),
    allowedSort: new Set(["ts"]),
  });

  const { page, limit, skip } = pagination(req.query, { defaultLimit: 50, maxLimit: 200 });

  const [items, total] = await Promise.all([
    AuditEvent.find(filter).sort(sort).skip(skip).limit(limit).lean(),
    AuditEvent.countDocuments(filter),
  ]);

  res.json({ items, meta: buildMeta({ page, limit, total, sortBy, order }) });
});

export default r;
```

> ⚠️ Si ton `queryBuilder` ne gère pas encore bien les clés en **dot-notation** (`actor.id`), fais un fallback rapide :
>
> ```js
> const q = {};
> if (req.query.event)     q.event = req.query.event;
> if (req.query["actor.id"])  q["actor.id"]  = req.query["actor.id"];
> if (req.query["target.id"]) q["target.id"] = req.query["target.id"];
> if (req.query.ts_gte || req.query.ts_lte) {
>   q.ts = {};
>   if (req.query.ts_gte) q.ts.$gte = new Date(req.query.ts_gte);
>   if (req.query.ts_lte) q.ts.$lte = new Date(req.query.ts_lte);
> }
> ```
>
> (Tu pourras remettre `queryBuilder` quand il sera clean.)

---

## 3) Monte la route dans `server.js`

```js
import adminAuditRoutes from "./routes/admin.audit.routes.js";
app.use("/api/admin", adminAuditRoutes);
```

---

## 4) N’OUBLIE PAS d’appeler `audit()` dans tes contrôleurs d’écriture

Exemples (après succès DB) :

```js
// create
audit(req, { event:"product.create", target:{ type:"product", id:newProduct._id, slug:newProduct.slug } });

// update
audit(req, { event:"product.update", target:{ type:"product", id }, diff:{ fields: Object.keys(allowedPart) } });

// delete
audit(req, { event:"product.delete", target:{ type:"product", id } });
```

---

## 5) Vérifications rapides

* `requireAuth` : il **doit** poser `req.user` (ou `req.session.user`) → sinon l’actor sera “anonymous”.
* Index : ajoute au minimum `AuditEventSchema.index({ ts: -1 })`.
* ESM partout (tu es déjà en `import/export`).

---

# Réponse à ta question

> “Si j’ajoute les fichiers ci-dessus, c’est bon, j’aurai mes logs ?”

✅ **Oui**, à condition de :

1. **séparer** correctement `models/AuditEvent.js` et `utils/audit.js` (versions ci-dessus),
2. **monter** la route `/api/admin/audit`,
3. **appeler** `audit()` dans chaque contrôleur **après** la réussite (create/update/delete),
4. t’assurer que `requireAuth` remplit `req.user`.

Après ça, tu verras tes événements :

* dans **Atlas** (collection `audit_events`),
* via **GET** `/api/admin/audit?...` (filtre date/event/actor/target + pagination).

---

# Conclusion

Tu es à un pas. Aligne la **forme** des données (actor objet ↔︎ schéma), retire la version “console only”, garde la version **Mongo**, monte la route, et appelle `audit()` dans tes contrôleurs → **audit opérationnel** sans overkill.

**Confiance : élevée.**
**À surveiller** : dot-notation dans `queryBuilder`, `requireAuth` bien câblé, et masque éventuel de champs sensibles dans `diff` si tu en ajoutes.
